シューティングでは**「弾に当たったらアウト」**というように、当たり判定が存在します。
Unityでは当たり判定にCollider（コライダー）という判定機能を持つコンポーネントを使用します。



### <span id="column-17"></span>Collider

Collider（コライダー）はRigidbodyの物理挙動と強く関係しています。Rigidbodyは**物理法則に従って動かす**ものですがColliderは**衝突（当たり）判定**を可能にするものになります。
詳しくは、[Physics
Components](http://docs.unity3d.com/ja/current/Components/comp-DynamicsGroup.html)を御覧ください。



<span id="h5-1"></span>5.1　プレイヤーに当たり判定を付ける
----------------------------------------------------------

Playerに**Box Collider 2D**をアタッチします。 **Size**は**X 0.02 Y
0.02**で、（おおよそ）1ドットの大きさの当たり判定にします。



![](images/game/05/attached_box_collider2d.png)
<br/>図5.1:



### <span id="h5-1-1"></span>トリガーにする

Playerをトリガーにします。**Box Collider 2D**の**Is
Trigger**にチェックを付けてください。



![](images/game/05/is_trigger_player.png)
<br/>図5.2:





### <span id="column-18"></span>**Trigger (トリガー)**

通常、コライダー同士はぶつかり反発します。ですが反発の必要としないものに関してはトリガーにします。トリガーにするにはコライダーの**Is
Trigger**にチェックを入れるだけです。そうするとコライダー同士はすり抜けます。トリガーは名前の通り何らかの別のイベントを起こすトリガーのために使用してください。



<span id="h5-2"></span>5.2　エネミーに当たり判定を付ける
--------------------------------------------------------

Enemyに**Polygon Collider
2D**をアタッチします。ですが、コライダーの大きさがエネミーの大きさに会わず不自然なものとなってしまいます。



![](images/game/05/default_polygon_collider2D.png)
<br/>図5.3:





### <span id="column-19"></span>Polygon Collider 2Dはメッシュを基準としてコライダーの形状を生成する

デフォルトではメッシュを基準としてコライダーが生成されます。メッシュの形状はTexture
Import Settingsである程度編集可能です。


![Texture TypeをAdvancedにしてMeshTypeやExtrude
Edgesを編集する](images/game/05/sprite_mesh.png)
<br/>図5.4: Texture TypeをAdvancedにしてMeshTypeやExtrude Edgesを編集する





そこでコライダーの形状を編集してみましょう。編集はshiftを押しながら編集することが可能です。



### <span id="column-20"></span>Polygon Collider 2Dを編集する

#### <span id="h5-2-0-1"></span>編集前の準備

コライダーの形状を編集していきますが、その時にスプライトの座標を移動させてしまったり、大きさを変更してしまったりすることがあります。
これはTransformの編集機能とコライダーの編集機能が有効になっており、操作領域が同じなためです。なので、Transformの編集機能を無効にします。
Transformの編集機能を無効にする方法はSprite
Rendererコンポーネントの**▼**を閉じます。


![SpriteRendererの詳細表示が有効な状態。Transformの編集機能が有効になる](images/game/05/open_sprite_renderer.png)
<br/>図5.5:
SpriteRendererの詳細表示が有効な状態。Transformの編集機能が有効になる





![SpriteRendererの詳細表示が無効な状態。Transformの編集機能が無効になる](images/game/05/custom_polygon_collider2D_2.png)
<br/>図5.6:
SpriteRendererの詳細表示が無効な状態。Transformの編集機能が無効になる



#### <span id="h5-2-0-2"></span>編集の仕方

コライダーの編集はShiftを押しながら行います。マウスをコライダーの緑色の線に合わせShiftを押します。そうすると緑色の■が表示されクリックするとその部分を頂点として動かすことが可能です。


![](images/game/05/edit_polygon_colider2D.png)
<br/>図5.7:







![](images/game/05/custom_polygon_collider2D_1.png)
<br/>図5.8:



### <span id="h5-2-1"></span>トリガーにする

Enemyをトリガーにします。**Polygon Collider 2D**の**Is
Trigger**にチェックを付けてください。



![](images/game/05/enemy_is_trigger.png)
<br/>図5.9:



<span id="h5-3"></span>5.3　弾に当たり判定を付ける
--------------------------------------------------

### <span id="h5-3-1"></span>コライダーをアタッチ

PlayerBulletの2つのBulletには**Polygon Collider
2D**を、EnemyBulletには**Circle Collider 2D**をアタッチします。 Circle
Collider 2Dの**Rudiusを0.07**にしてスプライトと同じ大きさにしましょう。



![](images/game/05/collider-bullets.png)
<br/>図5.10:



同じ形状のコライダーを作成するのは手間がかかるので片方ができたら**Copy
Component**でコピーして**Paste Component
Values**を使うようにしましょう。



### <span id="column-21"></span>コンポーネントをコピーする

<br/>図5.11のようにコンポーネントの文字上で右クリック、または歯車をクリックするとメニューが表示されます。
このメニューはコンポーネントを操作するためのものです。


![](images/game/05/copy_component.png)
<br/>図5.11:







![同じ内容のコンポーネントを追加する](images/game/05/paste_component_as_new.png)
<br/>図5.12: 同じ内容のコンポーネントを追加する





![コンポーネントの値を同じにする](images/game/05/paste_component_values.png)
<br/>図5.13: コンポーネントの値を同じにする







### <span id="h5-3-2"></span>トリガーにする

コライダーをトリガーにします。PlayerBulletの2つのBulletとEnemyBulletのコライダーの**Is
Trigger**にチェックを入れてください。





![](images/game/05/is_trigger_polygon.png)
<br/>図5.14:





![](images/game/05/is_trigger_circle.png)
<br/>図5.15:





ここまで出来たらPrefabを更新してそれぞれの弾をシーン上から削除しましょう。

<span id="h5-4"></span>5.4　スクリプトから当たり判定を検出する
--------------------------------------------------------------

スクリプトからトリガーの当たり判定を取得するには**「OnTriggerEnter2D」「OnTriggerStay2D」「OnTriggerExit2D」**の3つを使用します。



### <span id="column-22"></span>「OnTriggerEnter2D」「OnTriggerStay2D」「OnTriggerExit2D」

トリガーの当たり判定を取得するメソッドは「OnTriggerEnter2D」「OnTriggerStay2D」「OnTriggerExit2D」の３種類あります。これらは条件に合わせて使い分けるようにしてください。
詳しくは[MonoBehaviour](http://docs.unity3d.com/ja/current/ScriptReference/MonoBehaviour.html)を御覧ください。



今回は「プレイヤーは何かに当たったら爆発する」という仕様のもと実装していきます。
まず、**Spaceship.cs**にExplosionゲームオブジェクトを作成するためのコードを記述します。



Spaceship.cs

```cs
using UnityEngine;

[RequireComponent(typeof(Rigidbody2D))]
public class Spaceship : MonoBehaviour
{
    // 移動スピード
    public float speed;

    // 弾を撃つ間隔
    public float shotDelay;

    // 弾のPrefab
    public GameObject bullet;

    // 弾を撃つかどうか
    public bool canShot;

    // 爆発のPrefab
    public GameObject explosion;

    // 爆発の作成
    public void Explosion ()
    {
        Instantiate (explosion, transform.position, transform.rotation);
    }

    // 弾の作成
    public void Shot (Transform origin)
    {
        Instantiate (bullet, origin.position, origin.rotation);
    }

    // 機体の移動
    public void Move (Vector2 direction)
    {
        rigidbody2D.velocity = direction * speed;
    }
}
```



PlayerとEnemyのそれぞれ、インスペクター上でSpaceshipにExplosionのPrefabを格納してください。



![](images/game/05/spaceship_explosion.png)
<br/>図5.16:



Playerの当たり判定を検出するために、コードを追加します。



Player.cs

```cs
using UnityEngine;
using System.Collections;

public class Player : MonoBehaviour
{
    // Spaceshipコンポーネント
    Spaceship spaceship;

    IEnumerator Start ()
    {
        // Spaceshipコンポーネントを取得
        spaceship = GetComponent<Spaceship> ();

        while (true) {

            // 弾をプレイヤーと同じ位置/角度で作成
            spaceship.Shot (transform);

            // shotDelay秒待つ
            yield return new WaitForSeconds (spaceship.shotDelay);
        }
    }

    void Update ()
    {
        // 右・左
        float x = Input.GetAxisRaw ("Horizontal");

        // 上・下
        float y = Input.GetAxisRaw ("Vertical");

        // 移動する向きを求める
        Vector2 direction = new Vector2 (x, y).normalized;

        // 移動
        spaceship.Move (direction);
    }

    // ぶつかった瞬間に呼び出される
    void OnTriggerEnter2D (Collider2D c)
    {
        // 弾の削除
        Destroy(c.gameObject);

        // 爆発する
        spaceship.Explosion();

        // プレイヤーを削除
        Destroy (gameObject);
    }
}
```



この状態でゲームを再生してみましょう。
エネミーの弾に当たると爆発はしますが爆発が延々と続くはずです。



![](images/game/05/explode_forever.png)



<span id="h5-5"></span>5.5　爆発の制御
--------------------------------------

### <span id="h5-5-1"></span>アニメーションのループ設定

**Explode**のアニメーションファイルを選択し、インスペクター上に表示される**「Loop
Time」**のチェックを外してください。
こうすることで爆発のアニメーションは1回のみ再生されます。



![](images/game/05/loop_time.png)



<span id="h5-6"></span>5.6　爆発した後のゲームオブジェクト削除
--------------------------------------------------------------

爆発のアニメーションがループしなくなったとしても、爆発のゲームオブジェクトは残り続けます。
そこでアニメーションが終わった後、スクリプトの`Destroy`関数を使用してゲームオブジェクトを削除します。
**Explosion.cs**ファイルを作成し、ExplosionのPrefabにアタッチしてください。



![](images/game/05/attach_explosion_script.png)





Explosion.cs

```cs
using UnityEngine;

public class Explosion : MonoBehaviour
{
    void OnAnimationFinish ()
    {
        Destroy (gameObject);
    }
}
```



### <span id="h5-6-1"></span>アニメーションイベント

アニメーションが終わった後、**Explosion.cs**の**OnAnimationFinishメソッド**を呼び出すようにします。
`Window -> Animation`を選択して、Animationビューを表示させます。



![](images/game/05/menu_animation.png)



表示されたAnimationビューのタブ部分をドラッグすると他のタブ部分へ移動することが出来ます。



![](images/game/05/drag_animation_tab.png)



次に、Explosionプレハブをシーンへドラッグして、ゲームオブジェクトを作成します。



![](images/game/05/drag_explosion_prefab.png)



**Explosionのゲームオブジェクトを選択したままで**AnimationビューにExplodeの情報が表示されていることを確認して下さい。



![](images/game/05/select_explosion_gameobject.png)



AnimationEventを追加します。図5.17を見ながらイベントの追加を行ってください。



![](images/game/05/add_animation_event.png)
<br/>図5.17:



イベントの追加が終わったら**Explosionのゲームオブジェクト**を削除します。
ゲームを再生して、爆発後、Explosionが削除されていることを確認して下さい。

<span id="h5-7"></span>5.7　弾とエネミーが削除されるエリアを作る
----------------------------------------------------------------

今のままだと発射した弾やエネミーは延々と画面の外へ移動してしまいます。
そこで、弾やエネミーが削除される範囲を作成しましょう。
**空のGameObject**を作成し、名前を**DestroyArea**としました。さらに**Box
Collider 2D**をアタッチします。 **Is Trigger**にチェックを入れ、**Sizeは
X 9 Y 7** とします。



![](images/game/05/create_destroyarea.png)
<br/>図5.18:



このDestroyAreaに弾が当たり、**DestroyArea外に出てしまったら**削除されるようにします。
**DestroyArea.cs**を作成し、DestroyAreaにアタッチします。



DestroyArea.cs

```cs
using UnityEngine;

public class DestroyArea : MonoBehaviour
{
    void OnTriggerExit2D (Collider2D c)
    {
        Destroy (c.gameObject);
    }
}
```





![](images/game/05/attach_destroyarea_script.png)



再生して確認してみましょう。



![](images/game/05/bad_play_destroyarea.png)
<br/>図5.19:



再生と同時にプレイヤーが爆発しているはずです。それと同時にDestroyAreaが削除されています。



### <span id="column-23"></span>プレイヤーが爆発してしまっている理由

原因は単純で、**Player.cs**に記述している**OnTriggerEnter2D**メソッドが呼ばれてしまっているためです。このためDestroyAreaも削除されてしまっています。
少し難しい話になりますが、最初からゲームオブジェクトがコライダー内にあるとしても**OnTriggerEnter2D**は必ず呼ばれます。



この問題を解決する方法の１つとして、**レイヤー**を使います。

### <span id="h5-7-1"></span>レイヤーで当たり判定の制御

当たり判定を行うためにコライダーをゲームオブジェクトにアタッチしますが、必ずしも全てのコライダー同士で当たり判定が発生するとは限りません。少なくとも今回のシューティングゲームでは以下のように当たり判定に制限を設けなければいけません。



``` {.emlist}
 1: プレイヤーの弾とプレイヤーは当たらない
 2: エネミーの弾とエネミーは当たらない
 3: プレイヤーの弾とエネミーの弾は当たらない
 4: プレイヤーの弾同士は当たらない
 5: エネミーの弾同士は当たらない
 6: エネミー同士は当たらない
 7: プレイヤー同士は当たらない
```



これらの制限を行う上で最も簡単なのが**レイヤーで当たり判定を制御することです。**

#### <span id="h5-7-1-1"></span>レイヤーの設定

レイヤーを使うために、レイヤーの登録を行います。`Edit → Project Settings → Tags and Layers`を選択してください。



![](images/game/05/tag_and_layers.png)
<br/>図5.20:





### <span id="column-24"></span>Layer

レイヤーは一部の制限を設けるために使用することが多い機能です。今回のような当たり判定やカメラの描画、ライトの光など様々な用途があります。
詳しくは[Layers](http://docs.unity3d.com/ja/current/Components/Layers.html)を御覧ください。



今回はレイヤーを6つ用意します。



``` {.emlist}
 1:  Player
 2:  Enemy
 3:  Bullet (Player)
 4:  Bullet (Enemy)
 5:  DestroyArea
```





![](images/game/05/layer_list.png)
<br/>図5.21:



#### <span id="h5-7-1-2"></span>レイヤーで当たり判定の制御

先程登録したレイヤーで当たり判定の制御を行います。**Edit → Project
Settings → Physics 2D**を選択してください。



![](images/game/05/physics2D.png)
<br/>図5.22:



**Layer Collision
Matrix**を使い、レイヤー同士の当たり判定を行うかどうかの設定をします。デフォルトでは全てにチェックが付いています。これを図5.23のようにチェックを外してください。



![チェクを外すとそのレイヤー同士は当たり判定がなくなる](images/game/05/layer_collision_matrix.png)
<br/>図5.23: チェクを外すとそのレイヤー同士は当たり判定がなくなる



以下の画像のようにそれぞれのGameObject、Prefabにレイヤーを設定しましょう。



![](images/game/05/layer_destroyarea.png)





### <span id="column-25"></span>子要素も全て適用する

親の設定を変更した時、子要素もまとめて適用できることがあります。その時は図5.24のようなダイアログが表示されます。


![子要素のレイヤーをまとめて変更するかのダイアログ](images/game/05/apply_all.png)
<br/>図5.24: 子要素のレイヤーをまとめて変更するかのダイアログ







![](images/game/05/layer_enemy.png)





![](images/game/05/layer_enemy_bullet.png)





![](images/game/05/layer_player.png)





![](images/game/05/layer_player_bullet.png)



### <span id="h5-7-2"></span>スクリプトでレイヤー制御

**Layer Collision
Matrix**によって、ある程度の当たり判定の制御は行うことが可能になりました。
ですが今回は、**特定の場合だけ当たり判定を無視したい**という状況が発生します。`プレイヤーが爆発してしまっている理由`で話したような時です。

#### <span id="h5-7-2-1"></span>DestroyAreaに当たった時、OnTriggerExit2Dは呼び出したいけどOnTriggerEnter2Dは呼び出したくない！

今回はその方法の１つとして、スクリプトで対処する方法をご紹介します。
レイヤー情報を**gameObject**から取得することが可能です。取得できるのは数値なので、数値からProject
Settingsの**Tags and Layers**で設定したレイヤー名を取得します。
ここで気をつけて欲しいのはプレイヤーはエネミーとエネミーの弾２つに当たり判定があるということです。



Player.cs

```cs
using UnityEngine;
using System.Collections;

public class Player : MonoBehaviour
{
    // Spaceshipコンポーネント
    Spaceship spaceship;

    IEnumerator Start ()
    {
        // Spaceshipコンポーネントを取得
        spaceship = GetComponent<Spaceship> ();

        while (true) {

            // 弾をプレイヤーと同じ位置/角度で作成
            spaceship.Shot (transform);

            // shotDelay秒待つ
            yield return new WaitForSeconds (spaceship.shotDelay);
        }
    }

    void Update ()
    {
        // 右・左
        float x = Input.GetAxisRaw ("Horizontal");

        // 上・下
        float y = Input.GetAxisRaw ("Vertical");

        // 移動する向きを求める
        Vector2 direction = new Vector2 (x, y).normalized;

        // 移動
        spaceship.Move (direction);
    }

    // ぶつかった瞬間に呼び出される
    void OnTriggerEnter2D (Collider2D c)
    {
        // レイヤー名を取得
        string layerName = LayerMask.LayerToName(c.gameObject.layer);

        // レイヤー名がBullet (Enemy)の時は弾を削除
        if( layerName == "Bullet (Enemy)")
        {
            // 弾の削除
            Destroy(c.gameObject);
        }

        // レイヤー名がBullet (Enemy)またはEnemyの場合は爆発
        if( layerName == "Bullet (Enemy)" || layerName == "Enemy")
        {
            // 爆発する
            spaceship.Explosion();

            // プレイヤーを削除
            Destroy (gameObject);
        }
    }
}
```



設定を終えたらゲームを再生します。プレイヤーが削除されなくなりました。



![](images/game/05/good_play_destroyarea.png)
<br/>図5.25:



### <span id="h5-7-3"></span>エネミーの当たり判定

エネミーを**プレイヤーの弾に当たったら爆発**させ、同時にエネミーを削除します。
コードの追加はプレイヤーと同じくDestroyAreaを考慮し、`spaceship.Explosion()`を呼び出してExplosionのプレハブから爆発アニメーションを作成します。
そして最後にDestroyでエネミーを削除します。



Enemy.cs

```cs
using UnityEngine;
using System.Collections;

public class Enemy : MonoBehaviour
{
    // Spaceshipコンポーネント
    Spaceship spaceship;

    IEnumerator Start ()
    {

        // Spaceshipコンポーネントを取得
        spaceship = GetComponent<Spaceship> ();

        // ローカル座標のY軸のマイナス方向に移動する
        spaceship.Move (transform.up * -1);

        // canShotがfalseの場合、ここでコルーチンを終了させる
        if (spaceship.canShot == false) {
            yield break;
        }

        while (true) {

            // 子要素を全て取得する
            for (int i = 0; i < transform.childCount; i++) {

                Transform shotPosition = transform.GetChild(i);

                // ShotPositionの位置/角度で弾を撃つ
                spaceship.Shot (shotPosition);
            }

            // shotDelay秒待つ
            yield return new WaitForSeconds (spaceship.shotDelay);
        }
    }

    void OnTriggerEnter2D (Collider2D c)
    {
        // レイヤー名を取得
        string layerName = LayerMask.LayerToName(c.gameObject.layer);

        // レイヤー名がBullet (Player)以外の時は何も行わない
        if( layerName != "Bullet (Player)") return;

        // 弾の削除
        Destroy(c.gameObject);

        // 爆発
        spaceship.Explosion();

        // エネミーの削除
        Destroy(gameObject);
    }
}
```



ゲームを再生して確認してみましょう。 うまくいきましたか？





![プレイヤーがエネミーの弾に当たった状態](images/game/05/end_1.png)
<br/>図5.26: プレイヤーがエネミーの弾に当たった状態





![エネミーがプレイヤーの弾に当たった状態](images/game/05/end_2.png)
<br/>図5.27: エネミーがプレイヤーの弾に当たった状態





<span id="h5-8"></span>5.8　PlayerBulletゲームオブジェクトの削除
----------------------------------------------------------------

Bulletゲームオブジェクトの削除が行われますが親となるPlayerBulletが削除されていません。このまま弾を撃ち続けるとPlayerBulletがゴミとして残り続けてしまうため削除しなければいけません。
PlayerBulletの削除する方法はいくつか考えられますが、PlayerBulletは特に他に影響を与えるゲームオブジェクトではありません。
従って、最も簡単な**n秒後に削除**という方法で対処します。



Bullet.cs

```cs
using UnityEngine;

public class Bullet : MonoBehaviour
{
    // 弾の移動スピード
    public int speed = 10;

    // ゲームオブジェクト生成から削除するまでの時間
    public float lifeTime = 5;

    void Start ()
    {
        // ローカル座標のY軸方向に移動する
        rigidbody2D.velocity = transform.up.normalized * speed;

        // lifeTime秒後に削除
        Destroy (gameObject, lifeTime);
    }
}
```



PlayerBulletは1秒後に、EnemyBulletは5秒後に削除するようにしましょう。





![](images/game/05/bullet_lifetime_playerbullet.png)





![](images/game/05/bullet_lifetime_enemybullet.png)





### 第05回終わり

今回はここで終了です。つまずいてしまった方はプロジェクトファイルをダウンロードして新たな気持ちで次の回へ進みましょう。

[今回のプロジェクトファイルをダウンロード](project/game_05_ShootingGame.zip)
